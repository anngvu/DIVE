knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(GEOquery)
library(stringdist)
source("Code/misc.R")
# Specify a directory where GSE downloaded files are stored
GEOtemp <- "GEOtemp"
# Input file
GSELIST <- "test2.txt"
# Location/name for output file
REVIEW1 <- "sample_review.txt"
gses <- readLines(GSELIST)
# Download the GSE
getSamples <- function(gse) {
eset <- getGEO(GEO = gse, destdir = GEOtemp)[[1]]
pData(eset)
}
# if processing many, limit messages to avoid cluttering display
results <- suppressMessages(lapply(gses, function(x) try(getSamples(x))))
names(results) <- gses
gses <- readLines(GSELIST)
# Download the GSE
getSamples <- function(gse) {
eset <- getGEO(GEO = gse, destdir = GEOtemp)[[1]]
pData(eset)
}
# if processing many, limit messages to avoid cluttering display
results <- suppressMessages(lapply(gses, function(x) try(getSamples(x))))
names(results) <- gses
gses <- readLines(GSELIST)
# Download the GSE
getSamples <- function(gse) {
eset <- getGEO(GEO = gse, destdir = GEOtemp)[[1]]
pData(eset)
}
# if processing many, limit messages to avoid cluttering display
results <- suppressMessages(lapply(gses, function(x) try(getSamples(x))))
names(results) <- gses
ok <- allOK(results)
table(ok)
cat("GSEs that failed:", names(results)[!ok])
results <- results[ok] # Go back to failures later, proceed with OK
# Experiment Type (1-Channel or 2-Channel; more specific assignments, i.e. whether there was dye swap, happens in human review)
inferXPType <- function(DT) {
default <- "1C"
ch2 <- grep("source_name_ch2", names(DT))
if(length(ch2)) return("2C")
return(default)
}
ixpType <- sapply(results, inferXPType)
# BSM -- Molecule -- note: perhaps have a list of all known tlr ligands to match against
inferBSM <- function(DT) {
x1 <- rep("", nrow(DT))
bsmcol <- grep("agent|stimulation", names(DT))
if(length(bsmcol) == 1) {
info <- DT[bsmcol]
return(info)
}
return(x1)
}
iBSM <- sapply(results, inferBSM)
# BSMDCD -- Time
inferDCD <- function(DT) {
x1 <- rep("", nrow(DT))
# First find a column that specifically contains treatment info
tcol <- grep("^treatment|time", names(DT))
if(length(tcol)) {
info <- do.call(paste, DT[tcol])
} else { # Use information in sample title
info <- DT$title
}
m <- regexpr("[0-9]+ ?(d|h|D|H)|(D|d)(ay) ?[0-9]+", info)
x1[m != -1] <- regmatches(info, m)
# Sometimes time is stated as "overnight", which usually means "12 h"
x1[grepl("overnight", info)] <- "12h"
x1 <- tolower(gsub(" ", "", x1))
return(x1)
}
iDCD <- sapply(results, inferDCD)
# BSMDCD2 -- Dose/concentration
inferDCD2 <- function(DT) {
x1 <- rep("", nrow(DT))
dosecol <- grep("dose|concentration|amount|treatment", names(DT))
if(length(dosecol)) {
info <- do.call(paste, DT[dosecol])
m <- regexpr("[0-9.]+ ?(u|n|m)(g|M)?\\/?([A-Za-z]{2})", info)
x1[m != -1] <- regmatches(info, m)
}
return(x1)
}
iDCD2 <- sapply(results, inferDCD2)
# BiosampName -- to do: a more sophisticated implementation could also match to biosample ID
biosamps <- readLines("biosamps.txt") ## This is a list derived from "allbiosamples"
inferBiosamp <- function(DT) {
# First find the obvious columns containing cell line/type
cellcol <- grep("^cell.*ch1", colnames(DT))
if(length(cellcol)) {
cell <- do.call(paste, DT[cellcol])
return(cell)
} else {
tissuecol <- grep("^tissue.*ch1", colnames(DT))
if(length(tissuecol)) {
tissue <- do.call(paste, DT[tissuecol])
return(tissue)
} else { # Use the source_name_ch1,treatment_protocol_ch1 columns otherwise
bs <- lapply(biosamps, function(b) grepl(b, paste(DT$source_name_ch1, DT$treatment_protocol_ch1)))
names(bs) <- biosamps
bs <- bs[sapply(bs, sum) >= 1 ]
if(!length(bs)) return(rep("?", nrow(DT)))
bs <- bs[order(sapply(bs, sum), decreasing = T)]
nterm <- ifelse(length(bs) > 1, 2, 1)
x1 <- lapply(1:nterm, function(i) ifelse(bs[[i]], names(bs)[[i]], ""))
x1 <- do.call("paste", x1)
x1 <- trimws(x1)
return(x1)
}
}
}
iBiosamp <- sapply(results, inferBiosamp)
# Control?
inferCTRL <- function(DT) {
s <- DT$title
ctrl <- as.numeric(grepl("wt|wildtype|control|ctrl|healthy|media|medium|veh|unstim|untreated|mock", s, ignore.case = T))
}
iCTRL <- sapply(results, inferCTRL)
subP <- function(data) {
cols <- grep("title|geo_accession|source_name|description|platform|characteristics|treatment", names(data))
data <- data[, cols]
data <- lapply(data, function(x) gsub("\n", " ", x))
as.data.table(data)
}
export <- lapply(results, subP)
export <- rbindlist(export, fill = T)
export[, GSE := unlist(mapply(rep, gses, sapply(results, nrow)))]
newcols1 <- c("xpType", "RefDye", "Comment", "Group", "Batch", "Node", "NodeFunction", "BSM", "BSMDCD", "BSMDCD2", "BioSampName")
export[, (newcols1) := ""]
export[, c("Ignore") := 0]
export[, c("XP") := 1]
export[, xpType := ixpType]
export[, isCTRL := iCTRL]
export[, BioSampName := iBiosamp]
export[, BSMDCD := iDCD]
export[, BSMDCD2 := iDCD2]
neworder <- c("GSE", newcols1[1:4], "Ignore", "XP", "isCTRL", newcols1[5:11],
"title", "geo_accession", grep("^source|treatment", names(export), val = T),
grep("^char", names(export), val = T), "platform_id", grep("^desc", names(export), val = T))
setcolorder(export, neworder)
head(export)
write.table(export, REVIEW1, sep = "\t", row.names = F, quote = F)
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
source("Code/misc.R")
source("Code/makeContrasts.R")
REVIEW2 <- "sample_review2.txt"
REVIEW3 <- "sample_review3.txt"
CONTRASTS <- "sample_contrasts.txt"
dt <- makeGroupLabels(REVIEWTAB)
dt <- makeGroupLabels(REVIEW2)
unique(dt[, .(GSE, Group, Node, NodeFunction, BSM, BSMDCD, BioSampName)]) # check
contrasts <- makeContrasts(dt)
contrasts[]
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
source("Code/misc.R")
source("Code/makeContrasts.R")
# Input:
REVIEW2 <- "sample_review2.txt"
# Output files:
REVIEW3 <- "sample_review3.txt"
CONTRASTS <- "sample_contrasts.txt"
write.table(dt, REVIEW3, sep = "\t", row.names = F, quote = F)
write.table(contrasts, CONTRASTS, sep = "\t", row.names = F, quote = F)
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
source("Code/misc.R")
source("Code/fitter.R")
datadir <- "GEOtemp/"
resultsdir <- "Results/"
REVIEW3 <- "sample_review3.txt"
CONTRASTS <- "sample_contrasts.txt"
DT <- fread(REVIEW3)
DT <- DT[GSE != "", 1:17]
setkey(DT, GSE)
contrasts <- fread(CONTRASTS, colClasses = c("RefDye" = "character", "Comment" = "character", "Group" = "character", "Batch" = "character",
"Node" = "character", "NodeFunction" = "character"))
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
source("Code/misc.R")
source("Code/fitter.R")
datadir <- "GEOtemp/"
resultsdir <- "Results/"
REVIEW3 <- "sample_review3.txt"
CONTRASTS <- "sample_contrasts.txt.csv"
DT <- fread(REVIEW3)
DT <- DT[GSE != "", 1:17]
setkey(DT, GSE)
contrasts <- fread(CONTRASTS, colClasses = c("RefDye" = "character", "Comment" = "character", "Group" = "character", "Batch" = "character",
"Node" = "character", "NodeFunction" = "character"))
shiny::runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
plot_ly(data = px2, x = ~Diff.T1DvsHC, y = ~nlogP.T1DvsHC, text = ~Protein, type="scatter", mode = "markers",
color = ~nlogP.T1DvsHC, colors = pal, legendgroup = ~Label, showlegend = FALSE)
scale_color_viridis(px2$nlogP.AABvsHC)
library(viridis)
scale_color_viridis(px2$nlogP.AABvsHC)
plot_ly(data = px2, x = ~Diff.T1DvsHC, y = ~nlogP.T1DvsHC, text = ~Protein, type="scatter", mode = "markers",
color = ~nlogP.T1DvsHC, colors = "viridis", legendgroup = ~Label, showlegend = FALSE)
plot_ly(data = px2, x = ~Diff.T1DvsHC, y = ~nlogP.T1DvsHC, text = ~Protein, type="scatter", mode = "markers",
color = ~nlogP.T1DvsHC, colorscale = "viridis", legendgroup = ~Label, showlegend = FALSE)
plot_ly(data = px2, x = ~Diff.T1DvsHC, y = ~nlogP.T1DvsHC, text = ~Protein, type="scatter", mode = "markers",
color = ~nlogP.T1DvsHC, colorscale = "magma", legendgroup = ~Label, showlegend = FALSE)
plot_ly(data = px2, x = ~Diff.T1DvsHC, y = ~nlogP.T1DvsHC, text = ~Protein, type="scatter", mode = "markers",
color = ~nlogP.T1DvsHC, legendgroup = ~Label, showlegend = FALSE)
colorscale <- magma(px2$nlogP.AABvsHC)
plot_ly(data = px2, x = ~Diff.T1DvsHC, y = ~nlogP.T1DvsHC, text = ~Protein, type="scatter", mode = "markers",
color = ~nlogP.T1DvsHC, legendgroup = ~Label, colors = colorscale, showlegend = FALSE)
magma(3)
colorscale <- scale_color_viridis(px2$nlogP.AABvsHC)
head(colorscale)
colorscale
plot_ly(data = px2, x = ~Diff.T1DvsHC, y = ~nlogP.T1DvsHC, text = ~Protein, type="scatter", mode = "markers",
color = ~nlogP.T1DvsHC, legendgroup = ~Label, colors = colorscale, showlegend = FALSE)
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
FALSE + 1
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
.a <- test
.a < ""
.a
a. <- ""
rm(a.)
.a <- "list"
.a
rm(.a)
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
head(gx$Gene)
shiny::runApp('nPOD/nPOD-App/DIVE')
shiny::runApp('nPOD/nPOD-App/DIVE')
removeUI("#matchUI",immediate = T)
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
req(!is.null(cohortdata$matchOpts))
runApp('nPOD/nPOD-App/DIVE')
tags$div(
fluidRow(
column(2,
HTML("<strong>Data fusion/parameter selection</strong><br>"),
helpText("All covariates guessed as shared by both datasets are used as match parameters, which does not necessarily represent the user-desired default.
Parameters can be adjusted in a drag-and-drop manner, i.e. bring over and connect those that should be used.")
),
column(2,
HTML("<strong>You are matching on</strong>"),
verbatimTextOutput("matchOn", placeholder = TRUE),
actionButton("match", "Match")),
column(8,
uiOutput("matchParameters")
))
)
runApp('nPOD/nPOD-App/DIVE')
removeUI("#matchUI", immediate = T)
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
fluidPage(fluidRow(
column(1,
br(),
actionButton("guideMatch", "Guide", icon = icon("info-circle"))
),
column(1,
h3("CohortX"),
helpText("(your cohort)")
),
column(2,
div(id = "cohortInput",
textInput("cohortName", "Your cohort name/label (optional)", value = "", placeholder = "e.g. 'DiViD', 'pilot'.."),
fileInput("cohortDataUpload",  HTML("<strong>Upload data to begin</strong>"), multiple = FALSE,
accept = c("text/csv", "text/comma-separated-values,text/plain", ".csv"),
buttonLabel = "Data")
)
),
column(1,
br(),
checkboxInput("outsideCohort", "non-nPOD cohort", value = T),
br(),
br(),
actionLink("cohortDataRequirements", icon = icon("exclamation"), "Data requirements")
),
column(1
),
column(6
)),
fluidRow(
column(1
),
column(1, style="border-top: 1px solid lightgray;",
br(),
h3("nPOD")
),
column(2, style="border-top: 1px solid lightgray;",
br(),
div(id = "nPODInput",
selectInput("matchType", "Type of matches to get from nPOD",
choices = list("No diabetes (negative control)" = c(`No-diabetes donors` = "ND"),
"T1D (positive control)" = c(`T1D donors` = "T1D"),
"Other" = c(`T2D donors` = "T2D", `Autoantibody-positive donors` = "AAb")))
)
),
column(2),
column(6,
div(id = "npodgraph", style="margin-top: -220px; z-index: 0; height: 500px;", plotlyOutput("npodgraph")),
div(style="position: absolute; margin-top: -200px; margin-left: -140px; top:0; left:0; z-index: 1;",
plotlyOutput("nPie"))
)),
fluidRow(
column(1),
column(11, style="padding-top: 20px;",
uiOutput("matchUI")
)
),
fluidRow(style="margin-top: 20px; padding-bottom: 50px;",
column(5, style="padding-right: 50px;",
uiOutput("matchResult")
),
column(3,
uiOutput("advancedMatchResult")
),
column(4,
uiOutput("advancedMatchResult2")
)
)
)
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
runApp('nPOD/nPOD-App/DIVE')
r2d3::r2d3("cellpack.js", data = read_json("test.json"), d3_version = 4)
r2d3::r2d3("cellpack.js", data = jsonlite::read_json("test.json"), d3_version = 4)
setwd("~/nPOD/nPOD-App/Tests")
setwd("~/nPOD/nPOD-App/Tests")
r2d3::r2d3("cellpack.js", data = jsonlite::read_json("test.json"), d3_version = 4)
jsonlite::read_json("test.json")
jsonlite::from_json("test.json")
jsonlite::read_json("flare.json")
library(data.table)
library(ontologyIndex)
library(ggsci)
# FUN ------------------------------------------
nest <- function(li, leaf) {
if(length(li) == 1) return(setNames(list(leaf[[li]]), li))
parent <- li[1]
child <- li[-1]
setNames(list(nest(child, leaf)), parent)
}
mergeLines <- function(l1, l2) modifyList(l1, l2, keep.null = T)
nestD3 <- function(parent, child) {
if(inherits(child, "data.frame")) return(list(name = parent, color = context.colors[parent], children = child))
list(name = parent, color = ifelse(length(child) > 1, context.colors[parent], "transparent"),
children = mapply(nestD3, names(child), child, USE.NAMES = F, SIMPLIFY = F))
}
cl <- get_ontology("cl.obo", propagate_relationships=c("part_of"))
cl2 <- get_ontology("cl.obo", propagate_relationships=c("is_a"))
db <- fread("../DIVE/Data/Columns.txt")
context.size <- db[, .N, by = TissueContext]
cells <- cl$name[cl$name %in% unique(db$CellTissue)]
ancestors <- lapply(names(cells), function(x) cl2$name[cl2$ancestors[[x]] ])
ancestors <- sapply(ancestors, function(x)
if(any(grepl("panc", x))) { "pancreas" }
else if ("leukocyte" %in% x) { "leukocyte" }
else if ("cell" %in% x) { "other cell" }
else if (any(grepl("tissue|organ|structure", x))) { "tissue/organ" }
else { "other" })
table(ancestors)
colors <- rep("#BDBDBDFF", length(ancestors))
# expect warning since 14 colors -> 13 items for pancreas
colors[ancestors == "pancreas"] <- c(unlist(lapply(c("pink", "red"), function(p) pal_material(p)(10)[8:2])))
colors[ancestors == "leukocyte"] <- c(unlist(lapply(c("indigo", "blue"), function(p) pal_material(p)(10)[1:10 %% 2 == 0])),
pal_material("teal")(10)[1:10 %% 3 == 0])
colors[ancestors == "other cell"] <- pal_material("purple")(2)
colors[ancestors == "tissue/organ"] <- "transparent"
cell.context.size <- db[, .(size = .N), by = .(CellTissue, TissueContext)]
cell.context.size[, color := colors[match(CellTissue, cells)]]
setnames(cell.context.size, old = c("CellTissue", "TissueContext"), c("name", "context"))
cell.context.size <- split(cell.context.size, by = "context")
lines <- cl$id[cl$name %in% unique(db$TissueContext)]
lines <- lapply(lines, function(x) cl$name[cl$ancestors[[x]]])
# group lines into those with intersecting ancestors
pancreas <- lines[sapply(lines, function(x) ("pancreas" %in% x) & length(x) > 1)]
pancreas <- lapply(pancreas, function(x) x[x != "endocrine system"]) # start from pancreas
names(pancreas) <- sapply(pancreas, last)
hemolymphoid <- lines[sapply(lines, function(x) any(grepl("hemolymphoid", x)))]
names(hemolymphoid) <- sapply(hemolymphoid, last)
other <- lines[sapply(lines, function(x) !any(grepl("pancreas|hemolymphoid", x)))]
names(other) <- sapply(other, last)
hierarchy <- c(Reduce(mergeLines, lapply(pancreas, function(x) nest(x, leaf = cell.context.size))),
Reduce(mergeLines, lapply(hemolymphoid, function(x) nest(x, leaf = cell.context.size))),
Reduce(mergeLines, lapply(other, function(x) nest(x, leaf = cell.context.size))))
hierarchy
context.colors <- list(unique(unlist(pancreas, use.names = F)),
unique(unlist(hemolymphoid, use.names =F)),
unique(unlist(other, use.names = F)))
context.colors <- mapply(function(x, p) setNames(pal_material(p)(length(x)), x), context.colors, list("yellow", "red", "brown"))
context.colors <- unlist(context.colors)
test <- jsonlite::toJSON(nestD3("root", hierarchy), auto_unbox = T)
test
r2d3::r2d3("cellpack.js", data = test, d3_version = 4)
context.colors
install.packages(c("ca", "caTools", "coda", "devtools", "doParallel", "dplyr", "DT", "evaluate", "ffbase", "flexdashboard", "ggplot2", "git2r", "jomo", "lme4", "MCMCpack", "nloptr", "Rcpp", "reshape", "rstudioapi", "shiny", "shinythemes", "snow", "stringi", "tinytex", "xfun", "yaml"))
